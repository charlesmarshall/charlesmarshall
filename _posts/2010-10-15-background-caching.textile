---
layout: default
title: Background Caching
category: web
keywords:
- php
- phpwax
- wax
- cache
- background cache
description: "A new feature of phpwax that we've been working on is a handy new way of handling the layout cache. With the new method, the user should only ever get 1 slow request to a page, after that point the cached version is always served."
introduction: "<p>A new feature of phpwax that we've been working on is a handy new way of handling the layout cache. With the new method, the user should only ever get 1 slow request to a page, after that point the cached version is always served.</p>"
---

To keep websites running fast phpwax has a built in caching system of different flavours: layout cache (the entire page), partial cache (segments of the page) and image cache.

h2. Layout Cache

The biggest gains come from using layout cache; almost the entire framework is circumvented with only the required files being loaded and ignoring the auto loader stage.

Layout cache currently supports both memcache and flat files, so if you have minimal memory you can use disk and vice-versa.

On each page load (when active) the cache engine is called, a unique identifier is created for the page (based on url, request data, session values etc) and then checked to see if it exists.

When it does, the time is then checked to make sure it is valid and then data is returned. This is were the big change is; traditionally if the data was no longer valid (too old etc) then nothing would be returned and everything would have to be recreated.

On larger sites this can lead to slow page loads every time a page gets beyond its lifetimes, and on sites with short lifetimes, that's not a good thing.

h3. In the Background

The updated version takes a different approach, as long as the cache exists it will always be returned, even if its out of date. This means that the user will always get the cached page, making for a faster experience.

However, you now have a site that is displaying old and out of date information; which isn't good.

To get around this we still check the cache for validity, return it even if it's no longer valid, but at this point a background process is created which allows the main code execution to continue, so there is no delay to the user.

The new process is a self contained script that excepts some meta data about the page in question so it can then go an retrieve the page with all the same information that was used to create it along with a flag to ensure that no cached values are used. 

Results from this process are then used to overwrite the existing cache entry so the next time its called the new data will be present.

h2. Partial Cache

Ideally it would be great to be able to recreate a cached partial in the same way we do for the layouts, but this currently isn't working.

Instead, I find mixing in partial cache with layout cache is very effective and something I have in use on our current big projects.

h2. Generalisation

Will soon be making a generic Curl class that adopts the same approach.

 
