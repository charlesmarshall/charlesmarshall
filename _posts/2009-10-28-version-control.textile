---
layout: post
title: Version Control
category: general
---

Version control is important... VERY IMPORTANT! I have yet to come across a single university / college course for programmers that even mentions it, never mind teaching it in detail.

No matter what element of computer work you're in (web, c++, java etc) you need to be using version control of some form. You do one update, say change a logo or adjust the number of centroids for your k-means algorithm, what do you if 3 days later you find out it was the wrong decision? If you're not using version control its going to be a painful experience and heavy reliance on your memory; after 3 days you might remember it, but what if it was 3 weeks, or months or even years? There is no way you will remember that far back!

This where good version control steps in. In the old old days you had "CVS":http://en.wikipedia.org/wiki/Concurrent_Versions_System ; please forgot this existed (even though it did pave the way). In 2000 the "Subversion":http://en.wikipedia.org/wiki/Subversion_(software) open source project was born.

h3. Subversion

It was fast and handled binary files very well; which is why it is the base for such things as "Dropbox":http://getdropbox.com. However, it does have draw backs. It's branching and tagging truly are a nightmare to use and it relies on a central point for a repository.

What this means is that you will need to be online in order to make commits; this is not ideal, how do you do work on a train or plane? You can't.

Subversions biggest weakness (in my opinion) is its problems with renaming things. Instead of marking your rename as a rename it adds the file again under its new name and deletes the old one... Leaving lots of opportunity to lose changes. Say I made some changes in the a random project file, renamed it, and then checked it in. Those changes would show in the new file, but not the old one....

Reverting back to a previous commit isn't exactly a barrel of laughs. However the difficulty you have to endure when working on the same project as someone else is the straw that broke this programmers back.

Lets say Bob is editing a large library file on Project X, say one that handles all file operations and makes several amends, but at the same time Jon made a whole bunch of amends to the same file. Checking those changes in is going to be interesting.

At best you will have to resolve conflicts with a merging utility and hope you got it right. At worst, they will have changed the same areas of the file and who knows what will get checked in. 

A better solution was needed... Just like buses you spend ages waiting for then 3 turn up at once!

h3. Distribution FTW

Instead of a centralised, upstream only repository you have a local repository to call your own. You can make your changes, commit them locally, revise your commits if you want and then push to whatever other repository you fancy. Working with version control offline is now possible!

Distributed version control systems come in many flavours, but the current favourites are:

* GiT
* Bazaar
* Mercurial

GiT is my DVCS of choice. The main reason for originally selecting GiT was its backwards compatibility with Subversion; @git svn@ basically allows your upstream origin to be a Subversion repository but keeping your local repository running on GiT!

h3. Working With GiT

First off, installing GiT is super simple:

* Windows has the ever wonderful Tortoise (TortoiseGiT)
* Linux is easy, as GiT was made by Linus, so in most distros its a single command to install
* OS X is based on FreeBSD and there is now a dmg install image

That should take you about 5 minutes. Once you're done you need to get used to the command set. Many people (Mercurial & Bazaar uses, wonder why?) always complain about the number of commands Git has, but lets be honest here, in daily usage you use 6 commands:

* @git init@
* @git checkout@
* @git add@
* @git commit@
* @git pull@
* @git push@

How hard is that? GiT is simple to use for ever day tasks and wins hands down when it comes to smart merging of conflicts etc. You can learn all 100+ commands, or you can be sensible and google for them when you need to use them!

h3. Simplicity

Although I am a programmer and treat the command line like a second home, GUIs such as GitX makes some of those complicated things much easier. For example the latest build of GitX allows you to commit changes on specific lines, line at a time! Doing a command line alternative to this would be horrific.

All they need to do is add a button to do a push command ...

Couple that with the very handy @Capistrano@ and deploying becomes easier.

h3. Negatives...

GiT is not perfect... Just google and I'm sure you'll find dozens of people slagging it off (documentation is for wimps :P ).

